# Design Patterns in Ruby

# Introduction

## 1. Introduction

Welcome to the course! You will be explained how it will work and what you'll
be learning.

### Show notes

* [Source code on GitHub](https://github.com/tuts-premium/gof-patterns-ruby)

## 2. Template Method

In this lesson you'll learn how to use the Template Method behavioral pattern.
It relies on inheritance principles to accomplish its fundamental goal.

## 3. Strategy

After knowing how the Template Method works, the Strategy pattern is an
alternative to the former as it solves similar problems with different
conditions at stake.

### Show notes

* [OmniAuth](https://github.com/intridea/omniauth)

## 4. Adapter

In this lesson you'll learn how to use the Adapter pattern in order to extract
a bottleneck operation into an isolated, testable class.

### Show notes

* [Nokogiri documentation](http://nokogiri.org/tutorials)

## 5. Decorator

The structural Decorator pattern allows you to separate concerns from an actual
data entity type of object.

## 6. Factory

The famous creational Factory pattern lets you isolate the process of creating
an object, depending on the requirements you face in a process.

## 7. Iterator

In this lesson you'll learn how to iterate through a complex object using an
iterator method.

## 8. Observer

The Observer pattern is well known in the Javascript world because of the
language's nature. Ruby can have the same behavior by registering callbacks in
your watched objects.

## 9. Singleton

The creational Singleton pattern lets you assure that a single instance of a
class is created throughout the entire application.

## 10. State

State is often overlooked as simply being the data in an object at a point in
time. Well, it's much more than and in this lesson you'll learn how to handle
state and its changes.

## 11. Builder

This lesson will demonstrate how to create a complex object using the Builder
pattern. It is a good alternative to simply creating all the necessary data
spread out across multiple instructions.

## 12. Chain of Responsibility

The Chain of Responsability allows for correct delegation of certain messages
being passed to an object. We will use metaprogramming concepts into an object
to fully embrace this pattern.

## 13. Command

In this lesson you'll learn how to use the Command pattern in order to separate
responsibilities of two distinct layers..

## 14. Mediator

This pattern is hard to master but rewarding. As you'll understand from the
example, the Mediator pattern allows for a concrete place to which you assign
a certain set of operations.

## 15. Proxy

The Proxy pattern lets you mask an object behind another object. That way you
can have other objects interact with your proxy and add features into it,
without compromising the original object.

## 16. Facade

The Facade pattern has a common use case in web applications, in the way that
Rails controllers and Sinatra routes are facades to your application.

In this lesson you'll learn how to implement the Facade pattern in your
application.

## 17. Final tips

Thank you for tuning into this course! We hope you have learned something new
and put it into practice in your development.

Be sure to give us feedback and questions through the forums.

### Show notes

* [SOLID
  Principles](blog.rubybestpractices.com/posts/gregory/055-issue-23-solid-design.html)
